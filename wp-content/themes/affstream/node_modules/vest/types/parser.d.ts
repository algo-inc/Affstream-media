import { Maybe } from "vest-utils";
import { TIsolate } from "vestjs-runtime";
declare enum Severity {
    WARNINGS = "warnings",
    ERRORS = "errors"
}
declare enum TestSeverity {
    Error = "error",
    Warning = "warning"
}
declare enum TestStatus {
    UNTESTED = "UNTESTED",
    SKIPPED = "SKIPPED",
    FAILED = "FAILED",
    WARNING = "WARNING",
    PASSING = "PASSING",
    PENDING = "PENDING",
    CANCELED = "CANCELED",
    OMITTED = "OMITTED"
}
type TestFn = () => TestResult;
type AsyncTest = Promise<void>;
type TestResult = Maybe<AsyncTest | boolean>;
type WithFieldName<F extends TFieldName = TFieldName> = {
    fieldName: F;
};
type TIsolateTest<F extends TFieldName = TFieldName, G extends TGroupName = TGroupName> = TIsolate<CommonTestFields<F, G> & IsolateTestPayload>;
type IsolateTestPayload<F extends TFieldName = TFieldName, G extends TGroupName = TGroupName> = CommonTestFields<F, G> & {
    severity: TestSeverity;
    status: TestStatus;
    asyncTest?: AsyncTest;
};
type CommonTestFields<F extends TFieldName = TFieldName, G extends TGroupName = TGroupName> = {
    message?: Maybe<string>;
    groupName?: G;
    fieldName: F;
    testFn: TestFn;
};
declare class SummaryFailure<F extends TFieldName, G extends TGroupName> implements WithFieldName<F> {
    fieldName: F;
    message: Maybe<string>;
    groupName: Maybe<G>;
    constructor(fieldName: F, message: Maybe<string>, groupName: Maybe<G>);
    static fromTestObject<F extends TFieldName, G extends TGroupName>(testObject: TIsolateTest<F, G>): SummaryFailure<F & string, G & string>;
}
interface Done<F extends TFieldName, G extends TGroupName> {
    (...args: [
        cb: (res: SuiteResult<F, G>) => void
    ]): SuiteRunResult<F, G>;
    (...args: [
        fieldName: F,
        cb: (res: SuiteResult<F, G>) => void
    ]): SuiteRunResult<F, G>;
}
interface SuiteSelectors<F extends TFieldName, G extends TGroupName> {
    getWarning(): Maybe<SummaryFailure<F, G>>;
    getWarning(fieldName: F): Maybe<string>;
    getWarning(fieldName?: F): GetSingularResponse<F, G>;
    getError(): Maybe<SummaryFailure<F, G>>;
    getError(fieldName: F): Maybe<string>;
    getError(fieldName?: F): GetSingularResponse<F, G>;
    getErrors(): FailureMessages;
    getErrors(fieldName: F): string[];
    getErrors(fieldName?: F): string[] | FailureMessages;
    getWarnings(): FailureMessages;
    getWarnings(fieldName: F): string[];
    getWarnings(fieldName?: F): string[] | FailureMessages;
    getErrorsByGroup(groupName: G): FailureMessages;
    getErrorsByGroup(groupName: G, fieldName: F): string[];
    getErrorsByGroup(groupName: G, fieldName?: F): string[] | FailureMessages;
    getWarningsByGroup(groupName: G): FailureMessages;
    getWarningsByGroup(groupName: G, fieldName: F): string[];
    getWarningsByGroup(groupName: G, fieldName?: F): string[] | FailureMessages;
    hasErrors(fieldName?: F): boolean;
    hasWarnings(fieldName?: F): boolean;
    hasErrorsByGroup(groupName: G, fieldName?: F): boolean;
    hasWarningsByGroup(groupName: G, fieldName?: F): boolean;
    isPending(fieldName?: F): boolean;
    isValid(fieldName?: F): boolean;
    isValidByGroup(groupName: G, fieldName?: F): boolean;
}
type GetSingularResponse<F extends TFieldName, G extends TGroupName> = Maybe<string | SummaryFailure<F, G>>;
declare class SummaryBase {
    errorCount: number;
    warnCount: number;
    testCount: number;
    pendingCount: number;
}
declare class SuiteSummary<F extends TFieldName, G extends TGroupName> extends SummaryBase {
    [Severity.ERRORS]: SummaryFailure<F, G>[];
    [Severity.WARNINGS]: SummaryFailure<F, G>[];
    groups: Groups<G, F>;
    tests: Tests<F>;
    valid: boolean;
}
type GroupTestSummary = SingleTestSummary;
type Groups<G extends TGroupName, F extends TFieldName> = Record<G, Group<F>>;
type Group<F extends TFieldName> = Record<F, GroupTestSummary>;
type Tests<F extends TFieldName> = Record<F, SingleTestSummary>;
type SingleTestSummary = SummaryBase & {
    errors: string[];
    warnings: string[];
    valid: boolean;
    pendingCount: number;
};
type FailureMessages = Record<string, string[]>;
type SuiteResult<F extends TFieldName, G extends TGroupName> = SuiteSummary<F, G> & SuiteSelectors<F, G> & {
    suiteName: SuiteName;
};
type SuiteRunResult<F extends TFieldName, G extends TGroupName> = SuiteResult<F, G> & {
    done: Done<F, G>;
};
type SuiteName = Maybe<string>;
type TFieldName<T extends string = string> = T;
type TGroupName<G extends string = string> = G;
declare function parse<F extends TFieldName, G extends TGroupName>(summary: SuiteSummary<F, G>): ParsedVestObject<F>;
type ParsedVestObject<F extends TFieldName> = {
    valid(fieldName?: F): boolean;
    tested(fieldName?: F): boolean;
    invalid(fieldName?: F): boolean;
    untested(fieldName?: F): boolean;
    warning(fieldName?: F): boolean;
    pending(fieldName?: F): boolean;
};
export { parse, ParsedVestObject };
//# sourceMappingURL=parser.d.ts.map