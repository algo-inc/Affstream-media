'use strict';

var vestUtils = require('vest-utils');

var ErrorStrings;
(function (ErrorStrings) {
    ErrorStrings["NO_ACTIVE_ISOLATE"] = "Not within an active isolate";
    ErrorStrings["UNABLE_TO_PICK_NEXT_ISOLATE"] = "Unable to pick next isolate. This is a bug, please report it to the Vest maintainers.";
    ErrorStrings["ENCOUNTERED_THE_SAME_KEY_TWICE"] = "Encountered the same key \"{key}\" twice. This may lead to inconsistent or overriding of results.";
    ErrorStrings["IVALID_ISOLATE_CANNOT_PARSE"] = "Invalid isolate was passed to IsolateSerializer. Cannot proceed.";
})(ErrorStrings || (ErrorStrings = {}));

var IsolateKeys;
(function (IsolateKeys) {
    IsolateKeys["Type"] = "$type";
    IsolateKeys["Keys"] = "keys";
    IsolateKeys["Key"] = "key";
    IsolateKeys["Parent"] = "parent";
    IsolateKeys["Data"] = "data";
    IsolateKeys["AllowReorder"] = "allowReorder";
})(IsolateKeys || (IsolateKeys = {}));
var MinifiedKeys;
(function (MinifiedKeys) {
    MinifiedKeys["Type"] = "$";
    MinifiedKeys["Keys"] = "K";
    MinifiedKeys["Key"] = "k";
    MinifiedKeys["Parent"] = "P";
    MinifiedKeys["Data"] = "D";
    MinifiedKeys["AllowReorder"] = "aR";
})(MinifiedKeys || (MinifiedKeys = {}));
const KeyToMinified = {
    [IsolateKeys.Type]: MinifiedKeys.Type,
    [IsolateKeys.Keys]: MinifiedKeys.Keys,
    [IsolateKeys.Parent]: MinifiedKeys.Parent,
    [IsolateKeys.Data]: MinifiedKeys.Data,
    [IsolateKeys.Key]: MinifiedKeys.Key,
    [IsolateKeys.AllowReorder]: MinifiedKeys.AllowReorder,
};
// This const is an object that looks like this:
// {
//   '$': '$type',
//   'K': 'keys',
//   'P': 'parent',
//   ...
// }
const MinifiedToKey = Object.entries(KeyToMinified).reduce((acc, [key, minified]) => Object.assign(acc, {
    [minified]: key,
}), {});

class IsolateMutator {
    static setParent(isolate, parent) {
        isolate.parent = parent;
        return isolate;
    }
    static saveOutput(isolate, output) {
        isolate.output = output;
        return isolate;
    }
    static setKey(isolate, key) {
        isolate.key = key;
        return isolate;
    }
    static addChild(isolate, child) {
        var _a;
        vestUtils.invariant(isolate);
        isolate.children = (_a = isolate.children) !== null && _a !== void 0 ? _a : [];
        isolate.children.push(child);
        IsolateMutator.setParent(child, isolate);
    }
    static removeChild(isolate, node) {
        var _a, _b;
        isolate.children =
            (_b = (_a = isolate.children) === null || _a === void 0 ? void 0 : _a.filter(child => child !== node)) !== null && _b !== void 0 ? _b : null;
    }
    static addChildKey(isolate, key, node) {
        var _a;
        vestUtils.invariant(isolate);
        isolate.keys = (_a = isolate.keys) !== null && _a !== void 0 ? _a : {};
        isolate.keys[key] = node;
    }
    static slice(isolate, at) {
        if (vestUtils.isNullish(isolate.children)) {
            return;
        }
        isolate.children.length = at;
    }
    static setData(isolate, data) {
        isolate.data = data;
    }
}

class IsolateSerializer {
    // eslint-disable-next-line max-statements, complexity
    static deserialize(node) {
        // the  assumption is that the tree is built correctly,
        // but the children are missing the parent property to
        // avoid circular references during serialization.
        // in the same way, the parents are missing the `keys` property
        // to avoid circular references during serialization.
        // we need to rebuild the tree and add back the parent property to the children
        // and the keys property to the parents.
        const root = vestUtils.isStringValue(node)
            ? JSON.parse(node)
            : Object.assign({}, node);
        IsolateSerializer.validateIsolate(root);
        const queue = [root];
        while (queue.length) {
            const current = queue.shift();
            const children = IsolateSerializer.getChildren(current);
            for (const key in MinifiedToKey) {
                const value = current[key];
                if (vestUtils.isNotNullish(value)) {
                    current[MinifiedToKey[key]] = value;
                    delete current[key];
                }
            }
            if (!children) {
                continue;
            }
            current.children = children.map(child => {
                var _a;
                const nextChild = Object.assign({}, child);
                IsolateMutator.setParent(nextChild, current);
                queue.push(nextChild);
                const key = nextChild.key;
                if (key) {
                    current.keys = (_a = current.keys) !== null && _a !== void 0 ? _a : {};
                    current.keys[key] = nextChild;
                }
                return nextChild;
            });
        }
        return root;
    }
    static serialize(isolate) {
        if (vestUtils.isNullish(isolate)) {
            return '';
        }
        return JSON.stringify(transformIsolate(isolate));
    }
    static getChildren(node) {
        return node.children ? [...node.children] : null;
    }
    static validateIsolate(node) {
        vestUtils.invariant(vestUtils.hasOwnProperty(node, IsolateKeys.Type) ||
            vestUtils.hasOwnProperty(node, KeyToMinified[IsolateKeys.Type]), vestUtils.text(ErrorStrings.IVALID_ISOLATE_CANNOT_PARSE));
    }
}
// eslint-disable-next-line max-statements, complexity
function transformIsolate(isolate) {
    const next = {};
    if (isolate.children) {
        next.children = isolate.children.map(transformIsolate);
    }
    for (const key in isolate) {
        if (key === 'children') {
            continue;
        }
        if (isKeyExcluededFromDump(key)) {
            continue;
        }
        const value = isolate[key];
        if (vestUtils.isNullish(value)) {
            continue;
        }
        if (vestUtils.hasOwnProperty(KeyToMinified, key)) {
            next[KeyToMinified[key]] = value;
        }
        else {
            next[key] = value;
        }
    }
    return next;
}
function isKeyExcluededFromDump(key) {
    return [IsolateKeys.Parent, IsolateKeys.Keys].includes(key);
}

exports.IsolateSerializer = IsolateSerializer;
