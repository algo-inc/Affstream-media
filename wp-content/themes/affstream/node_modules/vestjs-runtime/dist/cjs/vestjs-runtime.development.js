'use strict';

var vestUtils = require('vest-utils');
var context = require('context');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var IsolateKeys;
(function (IsolateKeys) {
    IsolateKeys["Type"] = "$type";
    IsolateKeys["Keys"] = "keys";
    IsolateKeys["Key"] = "key";
    IsolateKeys["Parent"] = "parent";
    IsolateKeys["Data"] = "data";
    IsolateKeys["AllowReorder"] = "allowReorder";
})(IsolateKeys || (IsolateKeys = {}));
var MinifiedKeys;
(function (MinifiedKeys) {
    MinifiedKeys["Type"] = "$";
    MinifiedKeys["Keys"] = "K";
    MinifiedKeys["Key"] = "k";
    MinifiedKeys["Parent"] = "P";
    MinifiedKeys["Data"] = "D";
    MinifiedKeys["AllowReorder"] = "aR";
})(MinifiedKeys || (MinifiedKeys = {}));
const KeyToMinified = {
    [IsolateKeys.Type]: MinifiedKeys.Type,
    [IsolateKeys.Keys]: MinifiedKeys.Keys,
    [IsolateKeys.Parent]: MinifiedKeys.Parent,
    [IsolateKeys.Data]: MinifiedKeys.Data,
    [IsolateKeys.Key]: MinifiedKeys.Key,
    [IsolateKeys.AllowReorder]: MinifiedKeys.AllowReorder,
};
// This const is an object that looks like this:
// {
//   '$': '$type',
//   'K': 'keys',
//   'P': 'parent',
//   ...
// }
const MinifiedToKey = Object.entries(KeyToMinified).reduce((acc, [key, minified]) => Object.assign(acc, {
    [minified]: key,
}), {});

class IsolateMutator {
    static setParent(isolate, parent) {
        isolate.parent = parent;
        return isolate;
    }
    static saveOutput(isolate, output) {
        isolate.output = output;
        return isolate;
    }
    static setKey(isolate, key) {
        isolate.key = key;
        return isolate;
    }
    static addChild(isolate, child) {
        var _a;
        vestUtils.invariant(isolate);
        isolate.children = (_a = isolate.children) !== null && _a !== void 0 ? _a : [];
        isolate.children.push(child);
        IsolateMutator.setParent(child, isolate);
    }
    static removeChild(isolate, node) {
        var _a, _b;
        isolate.children =
            (_b = (_a = isolate.children) === null || _a === void 0 ? void 0 : _a.filter(child => child !== node)) !== null && _b !== void 0 ? _b : null;
    }
    static addChildKey(isolate, key, node) {
        var _a;
        vestUtils.invariant(isolate);
        isolate.keys = (_a = isolate.keys) !== null && _a !== void 0 ? _a : {};
        isolate.keys[key] = node;
    }
    static slice(isolate, at) {
        if (vestUtils.isNullish(isolate.children)) {
            return;
        }
        isolate.children.length = at;
    }
    static setData(isolate, data) {
        isolate.data = data;
    }
}

var ErrorStrings;
(function (ErrorStrings) {
    ErrorStrings["NO_ACTIVE_ISOLATE"] = "Not within an active isolate";
    ErrorStrings["UNABLE_TO_PICK_NEXT_ISOLATE"] = "Unable to pick next isolate. This is a bug, please report it to the Vest maintainers.";
    ErrorStrings["ENCOUNTERED_THE_SAME_KEY_TWICE"] = "Encountered the same key \"{key}\" twice. This may lead to inconsistent or overriding of results.";
    ErrorStrings["IVALID_ISOLATE_CANNOT_PARSE"] = "Invalid isolate was passed to IsolateSerializer. Cannot proceed.";
})(ErrorStrings || (ErrorStrings = {}));

class IsolateInspector {
    static at(isolate, at) {
        var _a, _b;
        if (vestUtils.isNullish(isolate)) {
            return null;
        }
        return (_b = (_a = isolate.children) === null || _a === void 0 ? void 0 : _a[at]) !== null && _b !== void 0 ? _b : null;
    }
    static cursor(isolate) {
        var _a, _b;
        if (vestUtils.isNullish(isolate)) {
            return 0;
        }
        return (_b = (_a = isolate.children) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
    static canReorder(isolate) {
        if (vestUtils.isNullish(isolate)) {
            return false;
        }
        return IsolateInspector.allowsReorder(isolate.parent);
    }
    static allowsReorder(isolate) {
        return (isolate === null || isolate === void 0 ? void 0 : isolate.allowReorder) === true;
    }
    static usesKey(isolate) {
        if (vestUtils.isNullish(isolate)) {
            return false;
        }
        return vestUtils.isNotNullish(isolate.key);
    }
    static getChildByKey(isolate, key) {
        var _a, _b;
        if (vestUtils.isNullish(isolate)) {
            return null;
        }
        return (_b = (_a = isolate.keys) === null || _a === void 0 ? void 0 : _a[key]) !== null && _b !== void 0 ? _b : null;
    }
}

function isIsolateType(node, type) {
    return (node === null || node === void 0 ? void 0 : node[IsolateKeys.Type]) === type;
}
function isSameIsolateType(a, b) {
    return isIsolateType(a, b[IsolateKeys.Type]);
}
function isSameIsolateIdentity(a, b) {
    return Object.is(a, b) || (isSameIsolateType(a, b) && a.key === b.key);
}

var IsolateSelectors = /*#__PURE__*/Object.freeze({
    __proto__: null,
    isIsolateType: isIsolateType,
    isSameIsolateIdentity: isSameIsolateIdentity,
    isSameIsolateType: isSameIsolateType
});

const PersistedContext = context.createCascade((stateRef, parentContext) => {
    if (parentContext) {
        return null;
    }
    vestUtils.invariant(stateRef.historyRoot);
    const [historyRootNode] = stateRef.historyRoot();
    const ctxRef = {};
    vestUtils.assign(ctxRef, {
        historyNode: historyRootNode,
        runtimeNode: null,
        runtimeRoot: null,
        stateRef,
    });
    return ctxRef;
});
const Run = PersistedContext.run;
const RuntimeApi = {
    Run,
    addNodeToHistory,
    createRef,
    persist,
    reset,
    useAvailableRoot,
    useCurrentCursor,
    useHistoryRoot,
    useLoadRootNode,
    useXAppData,
};
function useXAppData() {
    return useX().stateRef.appData;
}
function createRef(Reconciler, setter) {
    return Object.freeze({
        Bus: vestUtils.bus.createBus(),
        Reconciler,
        appData: vestUtils.optionalFunctionValue(setter),
        historyRoot: vestUtils.tinyState.createTinyState(null),
    });
}
function useReconciler() {
    return useX().stateRef.Reconciler;
}
function persist(cb) {
    const prev = PersistedContext.useX();
    return ((...args) => {
        var _a;
        const ctxToUse = (_a = PersistedContext.use()) !== null && _a !== void 0 ? _a : prev;
        return PersistedContext.run(ctxToUse.stateRef, () => cb(...args));
    });
}
function useX() {
    return PersistedContext.useX();
}
function useHistoryRoot() {
    return useX().stateRef.historyRoot();
}
function useHistoryIsolate() {
    return useX().historyNode;
}
/**
 * Returns the history isolate at the current position.
 * If there is a parent isolate, it returns the history node from the parent's children.
 * Otherwise, it returns the history node.
 * @returns {Nullable<TIsolate>} The history isolate at the current position.
 */
function useHistoryIsolateAtCurrentPosition() {
    const parent = useIsolate();
    // This is most likely the historic counterpart of the parent node
    const historyNode = useHistoryIsolate();
    if (parent) {
        // If we have a parent, we need to get the history node from the parent's children
        // We take the history node from the cursor of the active node's children
        return IsolateInspector.at(historyNode, IsolateInspector.cursor(parent));
    }
    return historyNode;
}
function addNodeToHistory(node) {
    const parent = useIsolate();
    if (parent) {
        useSetNextIsolateChild(node);
    }
    else {
        useSetHistory(node);
    }
    IsolateMutator.setParent(node, parent);
}
function useSetHistory(history) {
    const [, setHistoryRoot] = useHistoryRoot();
    setHistoryRoot(history);
}
function useHistoryKey(key) {
    if (vestUtils.isNullish(key)) {
        return null;
    }
    const historyNode = useX().historyNode;
    return IsolateInspector.getChildByKey(historyNode, key);
}
function useIsolate() {
    var _a;
    return (_a = useX().runtimeNode) !== null && _a !== void 0 ? _a : null;
}
function useCurrentCursor() {
    const isolate = useIsolate();
    return isolate ? IsolateInspector.cursor(isolate) : 0;
}
function useRuntimeRoot() {
    return useX().runtimeRoot;
}
function useSetNextIsolateChild(child) {
    const currentIsolate = useIsolate();
    vestUtils.invariant(currentIsolate, ErrorStrings.NO_ACTIVE_ISOLATE);
    IsolateMutator.addChild(currentIsolate, child);
}
function useSetIsolateKey(key, node) {
    if (!key) {
        return;
    }
    const currentIsolate = useIsolate();
    vestUtils.invariant(currentIsolate, ErrorStrings.NO_ACTIVE_ISOLATE);
    if (vestUtils.isNullish(IsolateInspector.getChildByKey(currentIsolate, key))) {
        IsolateMutator.addChildKey(currentIsolate, key, node);
        return;
    }
    vestUtils.deferThrow(vestUtils.text(ErrorStrings.ENCOUNTERED_THE_SAME_KEY_TWICE, { key }));
}
function useAvailableRoot() {
    const root = useRuntimeRoot();
    if (root) {
        return root;
    }
    const [historyRoot] = useHistoryRoot();
    return historyRoot;
}
function reset() {
    const [, , resetHistoryRoot] = useHistoryRoot();
    resetHistoryRoot();
}
function useLoadRootNode(root) {
    useSetHistory(root);
}

function BaseReconciler(currentNode, historyNode) {
    if (vestUtils.isNullish(historyNode)) {
        return currentNode;
    }
    return currentNode;
}
class Reconciler {
    /**
     * Reconciles the current isolate with the history isolate.
     * If the current isolate is of a different type than the history isolate,
     * the current isolate is returned.
     * Otherwise, the reconciler function is called to determine the next isolate.
     * If the reconciler function returns null or undefined, the base reconciler is used.
     * If no history isolate exists, the current isolate is returned.
     * @param node The current isolate to reconcile.
     * @returns The next isolate after reconciliation.
     */
    static reconcile(node) {
        const localHistoryNode = useHistoryIsolateAtCurrentPosition();
        const nextNodeResult = pickNextNode(node, localHistoryNode);
        vestUtils.invariant(nextNodeResult, ErrorStrings.UNABLE_TO_PICK_NEXT_ISOLATE);
        return nextNodeResult;
    }
    static dropNextNodesOnReorder(reorderLogic, newNode, prevNode) {
        const didReorder = reorderLogic(newNode, prevNode);
        if (didReorder) {
            removeAllNextNodesInIsolate();
        }
        return didReorder;
    }
    static handleIsolateNodeWithKey(node) {
        vestUtils.invariant(IsolateInspector.usesKey(node));
        const prevNodeByKey = useHistoryKey(node.key);
        let nextNode = node;
        if (!vestUtils.isNullish(prevNodeByKey)) {
            nextNode = prevNodeByKey;
        }
        useSetIsolateKey(node.key, node);
        return nextNode;
    }
}
function pickNextNode(currentNode, historyNode) {
    var _a;
    if (vestUtils.isNullish(historyNode)) {
        return handleNoHistoryNode(currentNode);
    }
    if (!isSameIsolateType(currentNode, historyNode)) {
        return currentNode;
    }
    const reconciler = useReconciler();
    return ((_a = reconciler(currentNode, historyNode)) !== null && _a !== void 0 ? _a : BaseReconciler(currentNode, historyNode));
}
function handleNoHistoryNode(newNode) {
    if (IsolateInspector.usesKey(newNode)) {
        return Reconciler.handleIsolateNodeWithKey(newNode);
    }
    return newNode;
}
function removeAllNextNodesInIsolate() {
    const currentNode = useIsolate();
    const historyNode = useHistoryIsolate();
    if (!historyNode || !currentNode) {
        // This is probably unreachable, but TS is not convinced.
        // Let's play it safe.
        /* istanbul ignore next */
        return;
    }
    IsolateMutator.slice(historyNode, IsolateInspector.cursor(currentNode));
}

class Isolate {
    static create(type, callback, payload = undefined, key) {
        const parent = useIsolate();
        const newCreatedNode = IsolateMutator.setParent(baseIsolate(type, payload, key), parent);
        const nextIsolateChild = Reconciler.reconcile(newCreatedNode);
        const localHistoryNode = useHistoryIsolateAtCurrentPosition();
        const output = Object.is(nextIsolateChild, newCreatedNode)
            ? useRunAsNew(localHistoryNode, newCreatedNode, callback)
            : nextIsolateChild.output;
        IsolateMutator.setParent(nextIsolateChild, parent);
        IsolateMutator.saveOutput(nextIsolateChild, output);
        addNodeToHistory(nextIsolateChild);
        return nextIsolateChild;
    }
}
/**
 * Creates a new child isolate context where the local history node is the current history node, thus advancing the history cursor.
 * Runs the callback function and returns its output.
 * @param localHistoryNode The local history node.
 * @param current The current isolate.
 * @param callback The callback function to execute.
 * @returns The output of the callback function.
 */
function useRunAsNew(localHistoryNode, current, callback) {
    const runtimeRoot = useRuntimeRoot();
    // We're creating a new child isolate context where the local history node
    // is the current history node, thus advancing the history cursor.
    const output = Run(Object.assign({ historyNode: localHistoryNode, runtimeNode: current }, (!runtimeRoot && { runtimeRoot: current })), () => callback(current));
    current.output = output;
    return output;
}
function baseIsolate(type, payload = undefined, key = null) {
    const _a = payload !== null && payload !== void 0 ? payload : {}, { allowReorder } = _a, data = __rest(_a, ["allowReorder"]);
    return {
        [IsolateKeys.AllowReorder]: allowReorder,
        [IsolateKeys.Keys]: null,
        [IsolateKeys.Parent]: null,
        [IsolateKeys.Type]: type,
        [IsolateKeys.Data]: data,
        children: null,
        key,
        output: null,
    };
}

// eslint-disable-next-line
function walk(startNode, callback, visitOnly) {
    // If the startNode has no children, there is nothing to walk.
    if (vestUtils.isNullish(startNode.children)) {
        return;
    }
    let broke = false;
    // For each child Isolate object, call the callback function.
    for (const isolate of startNode.children) {
        if (broke) {
            return;
        }
        // If visitOnly is not provided or the predicate is satisfied, call the callback function.
        if (vestUtils.isNullish(visitOnly) || vestUtils.optionalFunctionValue(visitOnly, isolate)) {
            callback(isolate, breakout);
        }
        // If the breakout function has been called, stop the walk.
        if (broke) {
            return;
        }
        // Recursively walk through the child Isolate object.
        walk(isolate, (child, innerBreakout) => {
            callback(child, () => {
                innerBreakout();
                breakout();
            });
        }, visitOnly);
    }
    function breakout() {
        broke = true;
    }
}
// This function returns true if the given predicate function returns true for any Isolate object in the tree.
// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
function some(startNode, predicate, visitOnly) {
    let hasMatch = false;
    // Call the walk function with a callback function that sets hasMatch to true if the predicate is satisfied.
    walk(startNode, (node, breakout) => {
        if (predicate(node)) {
            breakout();
            hasMatch = true;
        }
    }, visitOnly);
    return hasMatch;
}
// This function returns true if the given predicate function returns true for any Isolate object in the tree.
// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
function has(startNode, match) {
    return some(startNode, () => true, match);
}
// traverses up to a parent node that satisfies the predicate
// and returns the first direct descendant that satisfies the predicate
function findClosest(startNode, predicate) {
    var _a, _b;
    let found = null;
    let current = startNode;
    while (current) {
        found = (_b = (_a = current.children) === null || _a === void 0 ? void 0 : _a.find(predicate)) !== null && _b !== void 0 ? _b : null;
        if (found) {
            break;
        }
        current = current.parent;
    }
    return found;
}
// This function returns the first Isolate object in the tree that satisfies the given predicate function.
// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
function find(startNode, predicate, visitOnly) {
    let found = null;
    // Call the walk function with a callback function that sets found to the current node if the predicate is satisfied.
    walk(startNode, (node, breakout) => {
        if (predicate(node)) {
            breakout();
            found = node;
        }
    }, visitOnly);
    return found;
}
// This function returns true if the given predicate function returns true for every Isolate object in the tree.
// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
function every(startNode, predicate, visitOnly) {
    let hasMatch = true;
    walk(startNode, (node, breakout) => {
        if (!predicate(node)) {
            breakout();
            hasMatch = false;
        }
    }, visitOnly);
    return hasMatch;
}
// This function removes all Isolate objects in the tree that
// satisfy the given predicate function and have a parent.
// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
function pluck(startNode, predicate, visitOnly) {
    walk(startNode, node => {
        if (predicate(node) && node.parent) {
            IsolateMutator.removeChild(node.parent, node);
        }
    }, visitOnly);
}
// Returns the closest ancestor Isolate object of the given
//startNode that satisfies the given predicate function.
function closest(startNode, predicate) {
    let current = startNode;
    do {
        if (predicate(current)) {
            return current;
        }
        current = current.parent;
    } while (current);
    return null;
}
// This function returns true if the closest ancestor Isolates of the
// given startNode that satisfies the given predicate function exists.
function closestExists(startNode, predicate) {
    return !!closest(startNode, predicate);
}

var IsolateWalker = /*#__PURE__*/Object.freeze({
    __proto__: null,
    closest: closest,
    closestExists: closestExists,
    every: every,
    find: find,
    findClosest: findClosest,
    has: has,
    pluck: pluck,
    some: some,
    walk: walk
});

function useBus() {
    return useX().stateRef.Bus;
}
/*
  Returns an emitter, but it also has a shortcut for emitting an event immediately
  by passing an event name.
*/
function useEmit(event, data) {
    const emit = useBus().emit;
    if (!vestUtils.isNullish(event)) {
        emit(event, data);
    }
    return persist(emit);
}
function usePrepareEmitter(event) {
    const emit = useEmit();
    return (arg) => emit(event, arg);
}

var Bus = /*#__PURE__*/Object.freeze({
    __proto__: null,
    useBus: useBus,
    useEmit: useEmit,
    usePrepareEmitter: usePrepareEmitter
});

class IsolateSerializer {
    // eslint-disable-next-line max-statements, complexity
    static deserialize(node) {
        // the  assumption is that the tree is built correctly,
        // but the children are missing the parent property to
        // avoid circular references during serialization.
        // in the same way, the parents are missing the `keys` property
        // to avoid circular references during serialization.
        // we need to rebuild the tree and add back the parent property to the children
        // and the keys property to the parents.
        const root = vestUtils.isStringValue(node)
            ? JSON.parse(node)
            : Object.assign({}, node);
        IsolateSerializer.validateIsolate(root);
        const queue = [root];
        while (queue.length) {
            const current = queue.shift();
            const children = IsolateSerializer.getChildren(current);
            for (const key in MinifiedToKey) {
                const value = current[key];
                if (vestUtils.isNotNullish(value)) {
                    current[MinifiedToKey[key]] = value;
                    delete current[key];
                }
            }
            if (!children) {
                continue;
            }
            current.children = children.map(child => {
                var _a;
                const nextChild = Object.assign({}, child);
                IsolateMutator.setParent(nextChild, current);
                queue.push(nextChild);
                const key = nextChild.key;
                if (key) {
                    current.keys = (_a = current.keys) !== null && _a !== void 0 ? _a : {};
                    current.keys[key] = nextChild;
                }
                return nextChild;
            });
        }
        return root;
    }
    static serialize(isolate) {
        if (vestUtils.isNullish(isolate)) {
            return '';
        }
        return JSON.stringify(transformIsolate(isolate));
    }
    static getChildren(node) {
        return node.children ? [...node.children] : null;
    }
    static validateIsolate(node) {
        vestUtils.invariant(vestUtils.hasOwnProperty(node, IsolateKeys.Type) ||
            vestUtils.hasOwnProperty(node, KeyToMinified[IsolateKeys.Type]), vestUtils.text(ErrorStrings.IVALID_ISOLATE_CANNOT_PARSE));
    }
}
// eslint-disable-next-line max-statements, complexity
function transformIsolate(isolate) {
    const next = {};
    if (isolate.children) {
        next.children = isolate.children.map(transformIsolate);
    }
    for (const key in isolate) {
        if (key === 'children') {
            continue;
        }
        if (isKeyExcluededFromDump(key)) {
            continue;
        }
        const value = isolate[key];
        if (vestUtils.isNullish(value)) {
            continue;
        }
        if (vestUtils.hasOwnProperty(KeyToMinified, key)) {
            next[KeyToMinified[key]] = value;
        }
        else {
            next[key] = value;
        }
    }
    return next;
}
function isKeyExcluededFromDump(key) {
    return [IsolateKeys.Parent, IsolateKeys.Keys].includes(key);
}

exports.Bus = Bus;
exports.Isolate = Isolate;
exports.IsolateInspector = IsolateInspector;
exports.IsolateMutator = IsolateMutator;
exports.IsolateSelectors = IsolateSelectors;
exports.IsolateSerializer = IsolateSerializer;
exports.Reconciler = Reconciler;
exports.VestRuntime = RuntimeApi;
exports.Walker = IsolateWalker;
