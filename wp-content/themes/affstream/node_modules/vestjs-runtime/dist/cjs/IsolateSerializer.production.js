"use strict";var e,t,i,n=require("vest-utils");!function(e){e.NO_ACTIVE_ISOLATE="Not within an active isolate",e.UNABLE_TO_PICK_NEXT_ISOLATE="Unable to pick next isolate. This is a bug, please report it to the Vest maintainers.",e.ENCOUNTERED_THE_SAME_KEY_TWICE='Encountered the same key "{key}" twice. This may lead to inconsistent or overriding of results.',e.IVALID_ISOLATE_CANNOT_PARSE="Invalid isolate was passed to IsolateSerializer. Cannot proceed."}(e||(e={})),function(e){e.Type="$type",e.Keys="keys",e.Key="key",e.Parent="parent",e.Data="data",e.AllowReorder="allowReorder"}(t||(t={})),function(e){e.Type="$",e.Keys="K",e.Key="k",e.Parent="P",e.Data="D",e.AllowReorder="aR"}(i||(i={}));const s={[t.Type]:i.Type,[t.Keys]:i.Keys,[t.Parent]:i.Parent,[t.Data]:i.Data,[t.Key]:i.Key,[t.AllowReorder]:i.AllowReorder},r=Object.entries(s).reduce(((e,[t,i])=>Object.assign(e,{[i]:t})),{});class a{static setParent(e,t){return e.parent=t,e}static saveOutput(e,t){return e.output=t,e}static setKey(e,t){return e.key=t,e}static addChild(e,t){var i;n.invariant(e),e.children=null!==(i=e.children)&&void 0!==i?i:[],e.children.push(t),a.setParent(t,e)}static removeChild(e,t){var i,n;e.children=null!==(n=null===(i=e.children)||void 0===i?void 0:i.filter((e=>e!==t)))&&void 0!==n?n:null}static addChildKey(e,t,i){var s;n.invariant(e),e.keys=null!==(s=e.keys)&&void 0!==s?s:{},e.keys[t]=i}static slice(e,t){n.isNullish(e.children)||(e.children.length=t)}static setData(e,t){e.data=t}}class l{static deserialize(e){const t=n.isStringValue(e)?JSON.parse(e):Object.assign({},e);l.validateIsolate(t);const i=[t];for(;i.length;){const e=i.shift(),t=l.getChildren(e);for(const t in r){const i=e[t];n.isNotNullish(i)&&(e[r[t]]=i,delete e[t])}t&&(e.children=t.map((t=>{var n;const s=Object.assign({},t);a.setParent(s,e),i.push(s);const r=s.key;return r&&(e.keys=null!==(n=e.keys)&&void 0!==n?n:{},e.keys[r]=s),s})))}return t}static serialize(e){return n.isNullish(e)?"":JSON.stringify(o(e))}static getChildren(e){return e.children?[...e.children]:null}static validateIsolate(i){n.invariant(n.hasOwnProperty(i,t.Type)||n.hasOwnProperty(i,s[t.Type]),n.text(e.IVALID_ISOLATE_CANNOT_PARSE))}}function o(e){const t={};e.children&&(t.children=e.children.map(o));for(const i in e){if("children"===i)continue;if(c(i))continue;const r=e[i];n.isNullish(r)||(n.hasOwnProperty(s,i)?t[s[i]]=r:t[i]=r)}return t}function c(e){return[t.Parent,t.Keys].includes(e)}exports.IsolateSerializer=l;
