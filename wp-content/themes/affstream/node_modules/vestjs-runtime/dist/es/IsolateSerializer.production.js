import{invariant as e,isNullish as t,isStringValue as n,isNotNullish as i,hasOwnProperty as r,text as s}from"vest-utils";var a,l,o;!function(e){e.NO_ACTIVE_ISOLATE="Not within an active isolate",e.UNABLE_TO_PICK_NEXT_ISOLATE="Unable to pick next isolate. This is a bug, please report it to the Vest maintainers.",e.ENCOUNTERED_THE_SAME_KEY_TWICE='Encountered the same key "{key}" twice. This may lead to inconsistent or overriding of results.',e.IVALID_ISOLATE_CANNOT_PARSE="Invalid isolate was passed to IsolateSerializer. Cannot proceed."}(a||(a={})),function(e){e.Type="$type",e.Keys="keys",e.Key="key",e.Parent="parent",e.Data="data",e.AllowReorder="allowReorder"}(l||(l={})),function(e){e.Type="$",e.Keys="K",e.Key="k",e.Parent="P",e.Data="D",e.AllowReorder="aR"}(o||(o={}));const c={[l.Type]:o.Type,[l.Keys]:o.Keys,[l.Parent]:o.Parent,[l.Data]:o.Data,[l.Key]:o.Key,[l.AllowReorder]:o.AllowReorder},d=Object.entries(c).reduce(((e,[t,n])=>Object.assign(e,{[n]:t})),{});class u{static setParent(e,t){return e.parent=t,e}static saveOutput(e,t){return e.output=t,e}static setKey(e,t){return e.key=t,e}static addChild(t,n){var i;e(t),t.children=null!==(i=t.children)&&void 0!==i?i:[],t.children.push(n),u.setParent(n,t)}static removeChild(e,t){var n,i;e.children=null!==(i=null===(n=e.children)||void 0===n?void 0:n.filter((e=>e!==t)))&&void 0!==i?i:null}static addChildKey(t,n,i){var r;e(t),t.keys=null!==(r=t.keys)&&void 0!==r?r:{},t.keys[n]=i}static slice(e,n){t(e.children)||(e.children.length=n)}static setData(e,t){e.data=t}}class y{static deserialize(e){const t=n(e)?JSON.parse(e):Object.assign({},e);y.validateIsolate(t);const r=[t];for(;r.length;){const e=r.shift(),t=y.getChildren(e);for(const t in d){const n=e[t];i(n)&&(e[d[t]]=n,delete e[t])}t&&(e.children=t.map((t=>{var n;const i=Object.assign({},t);u.setParent(i,e),r.push(i);const s=i.key;return s&&(e.keys=null!==(n=e.keys)&&void 0!==n?n:{},e.keys[s]=i),i})))}return t}static serialize(e){return t(e)?"":JSON.stringify(h(e))}static getChildren(e){return e.children?[...e.children]:null}static validateIsolate(t){e(r(t,l.Type)||r(t,c[l.Type]),s(a.IVALID_ISOLATE_CANNOT_PARSE))}}function h(e){const n={};e.children&&(n.children=e.children.map(h));for(const i in e){if("children"===i)continue;if(p(i))continue;const s=e[i];t(s)||(r(c,i)?n[c[i]]=s:n[i]=s)}return n}function p(e){return[l.Parent,l.Keys].includes(e)}export{y as IsolateSerializer};
