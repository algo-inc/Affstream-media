import { Nullable } from 'vest-utils';
declare enum IsolateKeys {
    Type = "$type",
    Keys = "keys",
    Key = "key",
    Parent = "parent",
    Data = "data",
    AllowReorder = "allowReorder"
}
type IsolateKey = Nullable<string>;
type TIsolate<P extends IsolatePayload = IsolatePayload> = {
    [IsolateKeys.AllowReorder]?: boolean;
    [IsolateKeys.Parent]: Nullable<TIsolate>;
    [IsolateKeys.Type]: string;
    [IsolateKeys.Keys]: Nullable<Record<string, TIsolate>>;
    [IsolateKeys.Data]: DataOnly<P>;
    children: Nullable<TIsolate[]>;
    key: IsolateKey;
    output: any;
} & UsedFeaturesOnly<P>;
type DataOnly<P extends IsolatePayload> = Omit<P, keyof IsolateFeatures>;
type UsedFeaturesOnly<P extends IsolatePayload> = Pick<P, keyof IsolateFeatures>;
type IsolateData = Record<string, any>;
type IsolatePayload = IsolateData & IsolateFeatures;
type IsolateFeatures = {
    [IsolateKeys.AllowReorder]?: boolean;
};
declare class IsolateSerializer {
    // eslint-disable-next-line max-statements, complexity
    static deserialize(node: Record<string, any> | TIsolate | string): TIsolate;
    static serialize(isolate: Nullable<TIsolate>): string;
    static getChildren(node: TIsolate): Nullable<TIsolate[]>;
    static validateIsolate(node: Record<string, any> | TIsolate): void;
}
export { IsolateSerializer };
//# sourceMappingURL=IsolateSerializer.d.ts.map