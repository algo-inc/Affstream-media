import { createField } from '@felte/core';

function failFor(name) {
    return function () {
        throw new TypeError(`Can't call "${name}" on HTMLFelteFieldElement. The element is not ready yet.`);
    };
}
function booleanCoverter(value) {
    return value === '' || (!!value && value !== 'false');
}
class FelteField extends HTMLElement {
    constructor() {
        super(...arguments);
        /**
         * @attr touchonchange
         */
        this.touchOnChange = false;
        /**
         * @attr valueprop
         */
        this.valueProp = 'value';
        /**
         * @attr inputevent
         */
        this.inputEvent = 'input';
        /**
         * @attr blurevent
         */
        this.blurEvent = 'focusout';
        /**
         * @attr
         */
        this.composed = false;
        /** @internal */
        this._onBlur = failFor('blur');
        /** @internal */
        this._ready = false;
        /** @internal */
        this._updateField = () => {
            var _a;
            const element = this.target
                ? this.querySelector(this.target)
                : this.firstElementChild;
            if (!element || element === this._element)
                return;
            this._element = element;
            (_a = this._destroy) === null || _a === void 0 ? void 0 : _a.call(this);
            this._destroy = undefined;
            this._createField();
        };
    }
    static get observedAttributes() {
        return [
            'name',
            'touchonchange',
            'valueprop',
            'inputevent',
            'blurevent',
            'composed',
            'value',
            'target',
        ];
    }
    /** @internal */
    static get attributeMap() {
        return {
            name: {
                converter: String,
                name: 'name',
            },
            touchonchange: {
                converter: booleanCoverter,
                name: 'touchOnChange',
            },
            valueprop: {
                converter: String,
                name: 'valueProp',
            },
            inputevent: {
                converter: String,
                name: 'inputEvent',
            },
            blurevent: {
                converter: String,
                name: 'blurEvent',
            },
            value: {
                converter: String,
                name: 'value',
            },
            composed: {
                converter: booleanCoverter,
                name: 'composed',
            },
            target: {
                converter: String,
                name: 'target',
            },
        };
    }
    attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue === newValue)
            return;
        const { converter, name: propName } = FelteField.attributeMap[name];
        this[propName] = converter(newValue);
    }
    set value(newValue) {
        var _a;
        (_a = this._onInput) === null || _a === void 0 ? void 0 : _a.call(this, newValue);
        this._value = newValue;
    }
    /**
     * @attr
     */
    get value() {
        return this._value;
    }
    blur() {
        this._onBlur();
    }
    get ready() {
        return this._ready;
    }
    /** @internal */
    _createField() {
        var _a;
        const { name, inputEvent, blurEvent, touchOnChange, value: defaultValue, composed, } = this;
        if (!name)
            throw new Error('<felte-field> must have a "name" attribute');
        const element = this._element;
        if (!element)
            return;
        element[this.valueProp] = defaultValue;
        const { field, onInput, onBlur } = createField(name, {
            touchOnChange,
            defaultValue,
            onFormReset: () => {
                this.value = defaultValue;
                element[this.valueProp] = defaultValue;
            },
        });
        this._onInput = onInput;
        this._onBlur = onBlur;
        const { destroy } = field(element);
        const handleInput = (e) => {
            const target = composed ? e.composedPath()[0] : e.target;
            this.value = target[this.valueProp];
        };
        const handleBlur = () => {
            onBlur();
        };
        element.addEventListener(inputEvent, handleInput);
        element.addEventListener(blurEvent, handleBlur);
        this._destroy = () => {
            destroy === null || destroy === void 0 ? void 0 : destroy();
            element.removeEventListener(inputEvent, handleInput);
            element.removeEventListener(inputEvent, handleBlur);
        };
        this._ready = true;
        (_a = this.onfeltefieldready) === null || _a === void 0 ? void 0 : _a.call(this);
        this.dispatchEvent(new Event('feltefieldready'));
    }
    connectedCallback() {
        setTimeout(() => {
            this._updateField();
            this._observer = new MutationObserver(this._updateField);
            this._observer.observe(this, { childList: true });
        });
    }
    disconnectedCallback() {
        var _a, _b;
        (_a = this._destroy) === null || _a === void 0 ? void 0 : _a.call(this);
        (_b = this._observer) === null || _b === void 0 ? void 0 : _b.disconnect();
    }
}

export { FelteField as F };
//# sourceMappingURL=FelteField-06bd1c96.js.map
