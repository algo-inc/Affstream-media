import { createForm, isEqual, createEventConstructors } from '@felte/core';

const subscriber_queue = [];
const noop = () => undefined;
function safe_not_equal(a, b) {
    return a != a
        ? b == b
        : a !== b || (a && typeof a === 'object') || typeof a === 'function';
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) {
                // store is ready
                const run_queue = !subscriber_queue.length;
                for (const subscriber of subscribers) {
                    subscriber[1]();
                    subscriber_queue.push(subscriber, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            subscribers.delete(subscriber);
            if (stop && subscribers.size === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

function failFor(name) {
    return function () {
        throw new TypeError(`Can't call "${name}" on HTMLFelteFormElement. The element is not ready yet.`);
    };
}
const storeKeys = [
    'data',
    'errors',
    'touched',
    'warnings',
    'isSubmitting',
    'isDirty',
    'isValid',
    'isValidating',
    'interacted',
];
function capitalizeFirst(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
}
/**
 * @event {CustomEvent} datachange
 * @event {CustomEvent} errorschange
 * @event {CustomEvent} warningschange
 * @event {CustomEvent} touchedchange
 * @event {CustomEvent} isvalidchange
 * @event {CustomEvent} issubmittingchange
 * @event {CustomEvent} isdirtychange
 * @event {CustomEvent} isvalidatingchange
 * @event {CustomEvent} interactedchange
 */
class FelteForm extends HTMLElement {
    constructor() {
        super(...arguments);
        /** @internal */
        this._configuration = {};
        /**
         * Stores (observables)
         *
         * @internal
         */
        this._storeValues = {
            data: undefined,
            errors: undefined,
            touched: undefined,
            warnings: undefined,
            isSubmitting: false,
            isDirty: false,
            isValid: undefined,
            isValidating: false,
            interacted: null,
        };
        this.setData = failFor('setData');
        this.setFields = failFor('setFields');
        this.setInitialValues = failFor('setInitialValues');
        this.addField = failFor('addField');
        this.unsetField = failFor('unsetField');
        this.swapFields = failFor('swapFields');
        this.moveField = failFor('moveField');
        this.resetField = failFor('resetField');
        this.reset = failFor('reset');
        this.submit = failFor('submit');
        this.createSubmitHandler = failFor('createSubmitHandler');
        this.setErrors = failFor('setErrors');
        this.setTouched = failFor('setTouched');
        this.setWarnings = failFor('setWarnings');
        this.setIsSubmitting = failFor('setIsSubmitting');
        this.setIsDirty = failFor('setIsDirty');
        this.setInteracted = failFor('setInteracted');
        /** @internal */
        this._ready = false;
        this.validate = failFor('validate');
        /** @internal */
        this._formElement = null;
        /** @internal */
        this._updateForm = () => {
            var _a;
            const formElement = this.querySelector('form');
            if (!formElement || formElement === this._formElement)
                return;
            this.dispatchEvent(new Event('felteconnect', { bubbles: true, composed: true }));
            this._formElement = formElement;
            (_a = this._destroy) === null || _a === void 0 ? void 0 : _a.call(this);
            this._destroy = undefined;
            this._createForm();
        };
    }
    set configuration(config) {
        this._configuration = config;
        if (this._destroy) {
            this._destroy();
            this._destroy = undefined;
            this._ready = false;
            this._createForm();
        }
    }
    get configuration() {
        return this._configuration;
    }
    get data() {
        return this._storeValues.data;
    }
    get errors() {
        return this._storeValues.errors;
    }
    get touched() {
        return this._storeValues.touched;
    }
    get warnings() {
        return this._storeValues.warnings;
    }
    get isSubmitting() {
        return this._storeValues.isSubmitting;
    }
    get isDirty() {
        return this._storeValues.isDirty;
    }
    get isValid() {
        return this._storeValues.isValid;
    }
    get isValidating() {
        return this._storeValues.isValidating;
    }
    get interacted() {
        return this._storeValues.interacted;
    }
    get ready() {
        return this._ready;
    }
    /** @internal */
    _createForm() {
        var _a;
        const formElement = this._formElement;
        if (!formElement)
            return;
        const config = this.configuration;
        this.elements = formElement.elements;
        const { form, cleanup, ...rest } = createForm(config, {
            storeFactory: writable,
        });
        this.setData = rest.setData;
        this.setFields = rest.setFields;
        this.setErrors = rest.setErrors;
        this.setTouched = rest.setTouched;
        this.setWarnings = rest.setWarnings;
        this.setIsSubmitting = rest.setIsSubmitting;
        this.setIsDirty = rest.setIsDirty;
        this.setInteracted = rest.setInteracted;
        this.setInitialValues = rest.setInitialValues;
        this.validate = rest.validate;
        this.addField = rest.addField;
        this.unsetField = rest.unsetField;
        this.swapFields = rest.swapFields;
        this.moveField = rest.moveField;
        this.resetField = rest.resetField;
        this.reset = rest.reset;
        this.submit = rest.handleSubmit;
        this.createSubmitHandler = rest.createSubmitHandler;
        const unsubs = storeKeys.map((key) => {
            return rest[key].subscribe(($value) => {
                if (isEqual($value, this._storeValues[key]))
                    return;
                this._storeValues[key] = $value;
                const handler = this[`on${capitalizeFirst(key)}Change`];
                if (typeof handler === 'function')
                    handler($value);
                this.dispatchEvent(new Event(`${key.toLowerCase()}change`));
            });
        });
        const { destroy } = form(formElement);
        const { createSubmitEvent, createErrorEvent, createSuccessEvent, } = createEventConstructors();
        const handleFelteSubmit = (e) => {
            const event = e;
            const submitEvent = createSubmitEvent();
            this.dispatchEvent(submitEvent);
            if (submitEvent.defaultPrevented)
                event.preventDefault();
            event.onSubmit = submitEvent.onSubmit;
            event.onSuccess = submitEvent.onSuccess;
            event.onError = submitEvent.onError;
        };
        const handleFelteSuccess = (e) => {
            const event = e;
            const successEvent = createSuccessEvent(event.detail);
            this.dispatchEvent(successEvent);
        };
        const handleFelteError = (e) => {
            const event = e;
            const errorEvent = createErrorEvent(event.detail);
            this.dispatchEvent(errorEvent);
            event.errors = errorEvent.errors;
            if (errorEvent.defaultPrevented)
                event.preventDefault();
        };
        formElement.addEventListener('feltesubmit', handleFelteSubmit);
        formElement.addEventListener('feltesuccess', handleFelteSuccess);
        formElement.addEventListener('felteerror', handleFelteError);
        this._destroy = () => {
            destroy();
            cleanup();
            formElement.removeEventListener('feltesubmit', handleFelteSubmit);
            formElement.removeEventListener('feltesuccess', handleFelteSuccess);
            formElement.removeEventListener('felteerror', handleFelteError);
            unsubs.forEach((unsub) => unsub());
        };
        this._ready = true;
        (_a = this.onFelteReady) === null || _a === void 0 ? void 0 : _a.call(this);
        this.dispatchEvent(new Event('felteready', { bubbles: true, composed: true }));
    }
    connectedCallback() {
        setTimeout(() => {
            this._updateForm();
            this._observer = new MutationObserver(this._updateForm);
            this._observer.observe(this, { childList: true });
        });
    }
    disconnectedCallback() {
        var _a, _b;
        (_a = this._destroy) === null || _a === void 0 ? void 0 : _a.call(this);
        (_b = this._observer) === null || _b === void 0 ? void 0 : _b.disconnect();
    }
    static get observedAttributes() {
        return ['id'];
    }
    attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue === newValue)
            return;
        switch (name) {
            case 'id':
                this.id = newValue;
                break;
        }
    }
}

export { FelteForm as F };
//# sourceMappingURL=FelteForm-dd99a4bd.js.map
